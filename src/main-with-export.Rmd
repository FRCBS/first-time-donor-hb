# ---
title: "Hemoglobin distributions and trends"
author: "Timo Asikainen"
date: "2025-02-20" 
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r load-packages}
# install.packages('moments')
library(dplyr)
library(lubridate)
library(tidyr)
library(moments)
library(openxlsx)
```
```{r working-directory-and-file-paths}
param=list()
param$wd = getwd()

# getwd() might behave differently depending on the environment where it is run (console vs. Rmd),
# therefore checking if working directory is set to the src folder and moving up if yes.
if (grepl('[/\\]src[/\\]?',param$wd)) {
   param$wd = sub('[/\\]src([/\\]?)$','\\1',param$wd)
}

dir.create(file.path(param$wd,"results"),showWarnings = FALSE)
dir.create(file.path(param$wd,"log"),showWarnings = FALSE)
param$result.file = file.path(param$wd,"results","data.xlsx")

# nb! Change this to point to the correct data 
param$donationdata = '/home/m.pothast/data/data.rdata'
param$country = 'NL' # Not used currently; country could also be assigned when reading in the various data
param$units = 'mmol/L' #or g/L or g/dL
param$cutoff_M <- 8.4 #will need to convert these to correct units
param$cutoff_F <- 7.8
CONVERTED = F
```

```{r load-data}
# The data is expected to be in the same for as in the long-term forecasts project, except for
# the column 'Hb' added in the donation table. The units used in Finland is g/l.
load(param$donationdata)
```


```{r convert to correct units}

#should set some values to NA, but these cuts are unit specific!

Hb <- donationdata$donation$Hb

Hb <- as.numeric(Hb) 
if (!CONVERTED){
  if (param$units == 'mmol/L'){
    #If mmol/L assume that there is only 1 decimal. So add a random number
    # between -0.05, 0.05 such that all Hb values in g/L exists 
    #if you do not do these you get weird jumps
    Hb <- round((round(Hb, 1)+0.1*(runif(length(Hb))-0.5))/0.0621)
    param$cutoff_M <- round(param$cutoff_M/0.0621)
    param$cutoff_F <- round(param$cutoff_F/0.0621)
    CONVERTED <- T
  } else if (param$units == 'g/dL'){
    Hb <- round(Hb * 10)
    param$cutoff_M <- round(param$cutoff_M*10)
    param$cutoff_F <- round(param$cutoff_F*10)
    CONVERTED <- T
  } else {
    stop("param$units should be any of [mmol/L, g/dL, g/L]")
  }
}
donationdata$donation$Hb <- Hb
```

```{r load-and-prcoess-data}

#Set very small or large values to nan (all in units g/L, but Hb is converted above)
is.na(donationdata$donation$Hb) <- donationdata$donation$Hb > 300
is.na(donationdata$donation$Hb) <- donationdata$donation$Hb < 1

simple = donationdata$donation %>%
  filter(!is.na(Hb)) %>% #filter NA's
  # filter(BloodDonationTypeKey %in% c('Whole Blood (K)','No Donation (E)')) %>%
  # VisitNoDonation is used in Finland during the recent years instead of No Donation (E)
  left_join(donationdata$donor[,c('releaseID','DateOfBirth','Sex','BloodGroup')],by='releaseID')
simple$age= as.numeric(difftime(simple$DonationDate,simple$DateOfBirth),unit="weeks")/52.25
simple$month = as.factor(month(simple$DonationDate))
simple$year = year(simple$DonationDate)
simple$year.factor = as.factor(simple$year)


simple$limit = param$cutoff_M
simple$limit[simple$Sex=='Female'] = param$cutoff_F
simple$deferred=0
simple$deferred[simple$Hb<simple$limit]=1

#Filter nan sex
simple <- simple %>% filter(!is.na(Sex))

#For NL should take only BloodDonationTypeKey == "N" for first donation
# date of first donation
date0 = simple %>%
  filter(BloodDonationTypeKey == "New") %>%
  group_by(releaseID) %>%
  summarise(date0=min(DonationDate),.groups='drop')
# 
# # first-time donations
donation0 = simple %>%
  inner_join(date0,join_by(x$DonationDate==y$date0,releaseID))

# # repeat donations; sent for sentinel
# donation.r = simple %>%
#   left_join(cbind(date0,sent=1),join_by(x$DonationDate==y$date0,releaseID)) %>%
#   filter(is.na(sent)) %>%
#   select(-sent) %>%
#   mutate(month=as.integer(month))
# 
# donation0$year=year(donation0$DonationDate)
# donation0$year.factor=as.factor(donation0$year)
```

```{r prepare-for-export}
# Annual Hb distributions by Sex
data.sets=c('donation0')#,'donation.r','simple')
hb.freq = NULL
for (ds in data.sets) {
  freq0 = get(ds) %>%
    mutate(data.set=if(ds == 'simple') 'all' else ds) %>%
    group_by(data.set,year,Sex,Hb) %>%
    summarise(n=n(),nas=sum(1*is.na(Hb)),deferred=sum(deferred,na.rm=TRUE),
              mean.age=mean(age,na.rm=TRUE),sd.age=sd(age,na.rm=TRUE),limit=min(limit),.groups='drop')
  hb.freq = if(is.null(hb.freq)) freq0 else rbind(hb.freq,freq0)
}

# Annual age distributions by Sex
# data.sets=c('donation0','donation.r','simple')
age.freq = NULL
for (ds in data.sets) {
  freq0 = get(ds) %>%
    mutate(data.set=if(ds == 'simple') 'all' else ds,age=as.integer(age)) %>%
    group_by(data.set,year,Sex,age) %>%
    summarise(n=n(),nas=sum(1*is.na(Hb)),deferred=sum(deferred,na.rm=TRUE),mean.hb=mean(Hb,na.rm=TRUE),sd.hb=sd(Hb,na.rm=TRUE),.groups='drop')
  age.freq = if(is.null(age.freq)) freq0 else rbind(age.freq,freq0)
}

# Month statistics
monthly = NULL
for (ds in data.sets) {
  monthly0 = get(ds) %>%
    mutate(data.set=ds) %>%
    group_by(data.set,year,Sex,month) %>%
    summarise(n=n(),nas=sum(1*is.na(Hb)),deferred=sum(deferred,na.rm=TRUE),mean=mean(Hb,na.rm=TRUE),sd=sd(Hb,na.rm=TRUE),
              mean.age=mean(age,na.rm=TRUE),sd.age=sd(age,na.rm=TRUE),nas=sum(1*is.na(Hb)),.groups='drop') 
  monthly = if(is.null(monthly)) monthly0 else rbind(monthly,monthly0)
}
```

Open questions:
- What to do with the garrison donations?
- What to do with the NA's?
- Should the lower parts be somehow masked: is there a risk of leaking personal data?

```{r export-data}
write.xlsx(list(annual.hb=hb.freq %>% filter(n > 20),annual.age=age.freq %>% filter(n > 20),montly.statistics=monthly %>% filter(n > 20)),file=file.path(param$wd,'exported-statistics.xlsx'))
```

This is the end of the processing and export part.

```{r function-definitions}
plotColBySex = function(basics,col,ylab,xvar='year') {
  sex.col = data.frame(sex=c('Female','Male'),col=c('red','blue'))
  rownames(sex.col)=sex.col$sex
  
  par(mar=c(2,4,0,4))
  plot.cols=c(col)
  plot(basics[[xvar]],basics[[plot.cols[1]]],type='n',ylab=ylab)
  for (i in 1:nrow(sex.col)) {
    data1 = basics[basics$Sex==sex.col$sex[i],]
    for (col in plot.cols) {
      lines(data1[[xvar]],data1[[col]],col=sex.col$col[i],lwd=2)
      
      for (suf in c('low','hi')) {
        ci.var = paste0(col,'.',suf)
        if (ci.var %in% names(basics)) {
          lines(data1[[xvar]],data1[[ci.var]],lty='dotted',lwd=1,col=sex.col$col[i])
        }
      }
      
      frml=paste0(col,'~',xvar)
      m=lm(formula(frml),data=data1)
      sm=summary(m)
      abline(a=sm$coeff[1,1],b=sm$coeff[2,1],col=sex.col$col[i],lty='dashed',lwd=2)
      text(x=min(data1[[xvar]]),y=min(data1[[col]])+0.01,
           labels=paste0('b=',round(100*sm$coeff[2,1],5),'%,p=',round(sm$coeff[2,4],3)),adj=c(0))
    }
  }
}

# Some of these function definitions may be obsolete, should check and remove the unnecessary ones.
plotHbDist = function(data0,sex,cutoff,zoom=TRUE) {
  sex0=data0[data0$year>=2005&data0$Sex==sex & 
              !is.na(data0$Hb)&data0$BloodDonationTypeKey %in% c('Whole Blood (K)','No Donation (E)'),c('Hb')]  
  freq = sex0 %>%
    group_by(Hb) %>%
    summarise(n=n()) %>%
    mutate(prop=n/sum(n))

  limits = NULL
  if (zoom)
    limits = c(cutoff-5,cutoff+5)
  plot(prop~Hb,data=freq,type='l',lwd=2,xlim=limits)

  mean0=mean(sex0$Hb)
  sd0=sd(sex0$Hb)
  
  text(x=cutoff,y=0.03,labels=paste0('mean=',mean0,', sd=',sd0))
  
  ndist=dnorm(unique(freq$Hb),mean=mean0,sd=sd0)
  lines(unique(freq$Hb),ndist)
  abline(v=cutoff,col='blue')
  
  return(list(mean0=mean0,sd0=sd0))
}

estimateTrend = function(final) {
  final.longer = matToLonger(final)
  final.longer$interceptFemale=1
  final.longer$interceptFemale[final.longer$Sex=='Male']=0
  final.longer$interceptMale=1-final.longer$interceptFemale
  m=lm(value~0+interceptFemale+interceptMale+year:Sex,data=final.longer)
  print(summary(m))
  return(m)
}

matToLonger = function(mat) {
  df1=as.data.frame(pivot_longer(cbind(Sex=rownames(mat)[1:2],mat[1:2,]),colnames(mat),names_to='year'))
  df1$year=as.integer(df1$year)
  return(df1)
}

# This function is in active use, but it doesn't seem to refer the functions above
plotYearSex = function(m,relative=FALSE) {
  cofs = summary(m)$coeff
  conames=rownames(cofs)
  codf=data.frame(name=conames,estimate=cofs[,1])
  wh=grep('(Male|Female)',conames)
  codf$Sex[wh]=sub('.*(Male|Female).*','\\1',conames[wh])
  wh=grep('[0-9][0-9][0-9][0-9]',conames)
  codf$year[wh]=sub('[^0-9]+([0-9]+).*','\\1',conames[wh])
  codf=cbind(codf,confint(m))
  
  codf=codf[!is.na(codf$year),]
  pah=pivot_wider(codf,names_from='year',values_from='estimate',id_cols=c('Sex'))
  rn = as.vector(pah[,1])
  pah=as.data.frame(pah[,-1])
  rownames(pah)=rn$Sex
  
  means=apply(pah,1,mean)
  if (!relative)
    means=0*means
  
  pah=pah-means
  
  pah2=pivot_wider(codf,names_from='year',values_from='2.5 %',id_cols=c('Sex'))
  pah2=as.data.frame(pah2[,-1])
  pah2=pah2-means
  pah3=pivot_wider(codf,names_from='year',values_from='97.5 %',id_cols=c('Sex'))
  pah3=as.data.frame(pah3[,-1])
  pah3=pah3-means
  
  pah.all=rbind(pah,pah2,pah3)
  
  matplot(t(pah.all),type='l',lty=c(rep('solid',2),rep('dashed',4)),col=rep(c('red','blue'),2),axes=FALSE)
  axis(2)
  axis(side=1,at=1:ncol(pah.all),labels=colnames(pah.all))
  return(pah.all)
}
```

```{r distribution-analysis}
# This is the function that correct the kink in a distriution (data0)
# The function can be either called with data0 != NULL; data0 should then have the structure of simple, donation0 or donation.r
#   and can be a subset of these.
# *or* with freq != NULL, with the structure of hb.freq
# Nb! This function operates on a single distribution
rectifyDistribution = function (data0,sex=NULL,cutoff=NULL,plot=TRUE,freq=NULL) {
  if (is.null(cutoff)) {
    if (is.null(sex)) {
      if (is.null(data0)) {
        sex = unique(freq$Sex)[1]
      } else
        sex = unique(data0$Sex)[1]
    } 
    #TODO: no hard-code
    cutoff = if (sex=='Female') param$cutoff_F else param$cutoff_M
  }

  if (!is.null(data0)) {
    # sex0=data0[data0$Sex==sex&!is.na(data0$Hb)&data0$BloodDonationTypeKey %in% c('Whole Blood (K)','No Donation (E)'),c('Hb')]  
    freq = data0 %>%
      group_by(Hb) %>%
      summarise(n=n()) %>%
      mutate(prop=n/sum(n))
  } else {
    freq = freq %>%
      group_by(Hb) %>%
      summarise(n=sum(n),.groups='drop')
  }
  
  freq = freq[!is.na(freq$Hb),]
  
  if (!'prop' %in% colnames(freq)) {
    sum.n = sum(freq$n) # -coalesce(freq$nas,0))
    freq$prop = freq$n / sum.n 
  }
  
  freq.mean = freq %>%
    filter(!is.na(Hb)) %>% # These are the summary rows for NA; leave them out at this point
    summarise(n2=sum(n),mean0=sum(Hb*(n))/n2,.groups='drop')
  
  freq.stats = freq %>%
    filter(!is.na(Hb)) %>% # These are the summary rows for NA; leave them out at this point
    mutate(dev=Hb-freq.mean$mean0) %>% # ,prop=n/n2) %>%
    group_by() %>%
    summarise(mean=min(freq.mean$mean0),n0=min(n),var=sum(prop*dev^2),sd=sqrt(var),
              skewness=sum(prop*(dev/sd)^3),kurtosis=sum(prop*(dev/sd)^4),.groups='drop')
  mean0= freq.stats$mean
  sd0 = freq.stats$sd

  Hb.values = sort(unique(freq$Hb))
  dx <- 1. #depends on units, but should now all be converted to g/L
  ndist=dnorm(Hb.values,mean=mean0,sd=sd0)*dx
  
  # Plotting the unchanged distribution
  if (plot) {
    plot(prop~Hb,data=freq,type='l',lwd=2)
    lines(Hb.values,ndist)
  
    # A plot showing the difference between the distribution defined by data0 and the
    # normal distribution estimated from that data
    plot(freq$prop-ndist~Hb.values)
    abline(v=cutoff,col='blue')
    abline(h=c(-1,1)*0.0005,col='red')
  }

  # This is the part that 
  cnt = 0
  freq2 = freq
  k = which(freq$Hb==cutoff) 
  while (TRUE) {
    diff = (freq2$prop-ndist)[1:(k-1)]
    wh = which(diff < -0.0005)
    if (length(wh) == 0)
      break
    wh0 = max(wh)
    ds0 = diff[wh0]
    
    diff.plus = (freq2$prop-ndist)[k:nrow(freq2)]
    wh = which(diff.plus > 0.0005)
    if (length(wh) == 0)
      break
    wh1 = min(wh)
    ds1 = diff.plus[wh1]
    
    to.adjust = min(-ds0,ds1)
    
    freq2$prop[wh0] = freq2$prop[wh0] + to.adjust
    freq2$prop[wh1+(k-1)] = freq2$prop[wh1+(k-1)] - to.adjust
    
    cnt = cnt + 1
    if (cnt > 1000) {
      print('max iterations exceeded (back-stop)')
      break
    }
  }

  mean1 = freq2 %>% 
      mutate(mom=Hb*prop) %>%
      summarise(mean=sum(mom))
  mean1=as.numeric(mean1)
  sd1 =  freq2 %>% 
      mutate(mom=(Hb-as.numeric(mean1))^2*prop) %>%
      summarise(sdx=sum(mom)) 
  sd1=sqrt(as.numeric(sd1))
  
  # The theoretical deferred proportion is computed here 
  #the cutoff-0.5 is unit specific for g/L
  deferred.prop = pnorm(cutoff-0.5,mean1,sd1)
# 
  if (plot) {
    plot(prop~Hb,data=freq,type='l',lwd=3,xlim=NULL)
    lines(prop~Hb,data=freq2,col='green', lwd=2)
    ndist2=dnorm(Hb.values,mean=mean1,sd=sd1)*dx
    lines(Hb.values,ndist2,col='red',lty='dotted',lwd=2)
    abline(v=cutoff,col='blue',lty='dashed')
    rect(mean1-0.1,0,mean1+0.1,0.001,col='pink',lwd=2) #TODO: fix hard code limits
    abline(v=mean1,lty='dotted',lwd=3)

    plot(freq2$prop-ndist2~Hb.values)
    abline(v=cutoff,col='blue',lty='dashed')
    abline(h=c(-1,1)*0.0005,col='red',lty='dashed')
  }

  return(list(dist=freq2,params=list(mean=mean1,sd=sd1,deferred.prop=deferred.prop)))
}
```


```{r}
# Example of rectifying the distribution
data0=simple
sex='Male'
cutoff=135

freq <- hb.freq[hb.freq$Sex=='Female', ]
# sum.n = sum(freq$n) # -coalesce(freq$nas,0))
# freq$prop = freq$n / sum.n

rectifyDistribution(NULL,'Female',param$cutoff_F,freq=freq)

# dist.male = rectifyDistribution(simple,'Male',cutoff)
# dist.female = rectifyDistribution(simple,'Female',cutoff)
```


```{r getStats-function}
# This function produces statistics of value.col (Hb or age) based on groups defined by group.col (can be year or age) and sex
# If age.freq is provided, the proportions are included in the results (relevant when value.col == 'Hb')
getStats = function(freq,value.col='Hb',group.col='year',n.filter=100,age.freq=NULL,age.breaks=c(-Inf,24,40,Inf),age.labels=c('young','mid','old')) {
  freq = data.frame(freq)
  
  if (is.null(n.filter) || is.na(n.filter))
    n.filter = 0
  
  wh = min(which(colnames(freq)==value.col))
  colnames(freq)[wh]='value'
  wh.group = min(which(colnames(freq)==group.col))
  colnames(freq)[wh.group]='group'

  new.basics.mean = freq %>%
    # filter(is.null(data.set) || data.set==data.set) %>%
    filter(!is.na(value)) %>% # These are the summary rows for NA; leave them out at this point
    group_by(group,Sex) %>%
    summarise(n2=sum(n-nas),deferred.prop=sum(deferred/n2),mean0=sum(value*(n-nas))/n2,.groups='drop')
  
  new.basics = freq %>%
    filter(!is.na(value)) %>% # These are the summary rows for NA; leave them out at this point
    inner_join(new.basics.mean,join_by(group,Sex)) %>%
    mutate(dev=value-mean0,prop=n/n2) %>%
    group_by(group,Sex) %>%
    summarise(mean=min(mean0),n0=min(n),n=min(n2),deferred.prop=min(deferred.prop),var=sum(prop*dev^2),sd=sqrt(var),
              skewness=sum(prop*(dev/sd)^3),kurtosis=sum(prop*(dev/sd)^4),.groups='drop') %>%
    mutate(sd.low=sqrt((n-1)*var/qchisq(c(.975), n-1))) %>%
    mutate(sd.hi =sqrt((n-1)*var/qchisq(c(.0275), n-1))) %>%
    mutate(mean.low=mean-qnorm(0.025)*sd/sqrt(n)) %>%
    mutate(mean.hi =mean-qnorm(0.975)*sd/sqrt(n)) %>%
    filter(n>n.filter) %>%
    data.frame()
  
  wh.group = min(which(colnames(new.basics)=='group'))
  colnames(new.basics)[wh.group]=group.col
  
  if (value.col=='Hb') {
    freq.limits = freq %>% group_by(group,Sex) %>% summarise(limit=min(limit),.groups='drop') %>% mutate(year=group)
    new.basics = new.basics %>%
      inner_join(freq.limits,join_by(year,Sex)) %>%
      mutate(theoretical.deferred.prop = pnorm(limit,mean,sd)) %>%
      dplyr::select(-limit)
  }
  
  if (!is.null(age.freq)) {
    year.totals = age.freq %>%
      group_by(year,Sex) %>%
      summarise(n2=sum(n),age=mean(age),.groups='drop')
    
    age2 = age.freq %>%
      mutate(group = cut(age,age.breaks,labels=age.labels)) %>%
      group_by(year,Sex,group) %>%
      summarise(n=sum(n),.groups='drop') %>%
      inner_join(year.totals,join_by(year,Sex)) %>%
      mutate(prop=n/n2) %>% # ,name=paste(year,Sex)) %>%
      pivot_wider(id_cols=c('year','Sex'),names_from='group',values_from='prop')


    new.basics = new.basics %>%
      inner_join(age2,join_by(year,Sex)) %>%
      inner_join(year.totals[,c('year','Sex','age')],join_by(year,Sex))
  }

  
  return(new.basics)
}
```

```{r basic-data-processing}
freq0=hb.freq[hb.freq$data.set=='donation0',]
rectifyDistribution(data0=NULL,freq=freq0[freq0$Sex=='Male',])
rv=by(freq0,freq0[,c('Sex','year')],function(x) unlist(rectifyDistribution(data0=NULL,freq=x,plot=FALSE)$params))
res=array2DF(rv)
res$year=as.integer(res$year)

# Basic statistics for the unrectified hb distributions
basics.all = getStats(hb.freq,age.freq = age.freq)

# Basic statistics joined with results from the rectified distributions
basics = inner_join(basics.all,res,
                    join_by(year,Sex),suffix=c('','.rectified'))
```

``` {r plotting}
# means and such
plotColBySex(basics,'mean','mean (actual data)')
plotColBySex(basics,'mean.rectified','theoretical mean (rectified)')
plotColBySex(basics,'sd','sd (actual data)')
plotColBySex(basics,'sd.rectified','theoretical sd (rectified)')

# deferral rates
plotColBySex(basics,'deferred.prop','actual percentage deferred')
plotColBySex(basics,'theoretical.deferred.prop','theoretical proportion deferred (unrectified distribution)')
plotColBySex(basics,'deferred.prop.rectified','theoretical proportion deferred (rectified distribution)')
# plotColBySex(basics,'dperc.lm','adjusted using estimated mean differences')
```

``` {r new-lm-approach}
newLMapproach = function(basics) {
  # This block relies on basics, so need to make sure it can be computed with the summary data
  # Plus must add countries overall
  # This all seems to be based on basics
  par(mar=c(2,4,0,0))
  data=basics[basics$Sex=='Female',]
  data.female=data
  mean.female=mean(data$deferred.prop)
  plot(deferred.prop~mean,data=data,ylim=c(0,0.15),xlim=c(130,160),col='red')
  m=lm(deferred.prop~mean,data=data)
  m1=lm(deferred.prop~mean+sd,data=data)
  sm=summary(m)
  sm1=summary(m1)
  sm1.female=sm1
  
  m2.female=NULL
  if ('young' %in% colnames(data)) {
    m2.female=lm(deferred.prop~mean+sd+young+old,data=data)
  }

    abline(a=sm$coeff[1,1],b=sm$coeff[2,1],col='red',lty='dashed',lwd=2)
  text(x=135,y=0.03,labels=paste0('b=',round(sm1$coeff[2,1],3),'\np=',round(sm1$coeff[2,4],3),'\nR',intToUtf8(178),'=',round(sm1$r.squared,3)),adj=c(0))
  data=basics[basics$Sex=='Male',]
  m=lm(deferred.prop~mean,data=data)
  m1=lm(deferred.prop~mean+sd,data=data)
  sm=summary(m)
  sm1=summary(m1)
  abline(a=sm$coeff[1,1],b=sm$coeff[2,1],col='blue',lty='dashed',lwd=2)
  points(data$mean,data$deferred.prop,col='blue')
  text(x=155,y=0.06,labels=paste0('b=',round(sm1$coeff[2,1],3),'\np=',round(sm1$coeff[2,4],3),'\nR',intToUtf8(178),'=',round(sm1$r.squared,3)),adj=c(0))
  plot(data$year,sm1.female$residuals,col='red',ylim=c(-0.05,0.05),type='l',ylab='residuals',lwd=3)
  lines(data$year,sm1$residuals,col='blue',lwd=3)
  mean.male=mean(data$deferred.prop)
  lines(data$year,data.female$deferred.prop-mean.female,col='red',lty='dotted',lwd=2)
  lines(data$year,data$deferred.prop-mean.male,col='blue',lty='dotted',lwd=2)
  
  year=data$year
  residual=data.female$deferred.prop-mean.female
  m=lm(residual~year)
  summary(m)
  
  table(data$Sex)
  m1=lm(deferred.prop~mean+sd+age,data=data)
  summary(m1)
  
  m1=lm(deferred.prop~mean+sd+age,data=data.female)
  summary(m1)

  m2.male=NULL
  if ('young' %in% colnames(data)) {
    m2.male=lm(deferred.prop~mean+sd+young+old,data=data)
  }
  
  return(list(m.female=m2.female,m.male=m2.male))
}
```

```{r experimental-results}
# Do the young and old age proportions explain deferral rates:
# They do, but only for men 
rv=newLMapproach(basics)
summary(rv$m.female)
summary(rv$m.male)

plotColBySex(basics,'old','proportion of 40+ yrs of age')
```


```{r statistics-by-age}
agedist = getStats(age.freq %>% filter(data.set=='all'),value.col='mean.hb',group.col='age',n.filter=100)
plotColBySex(agedist,'mean',xvar = 'age',ylab='')

plotColBySex(agedist,'n',xvar = 'age',ylab='')
plotColBySex(agedist,'mean',xvar = 'age',ylab='')
plotColBySex(agedist,'sd',xvar = 'age',ylab='')

plotColBySex(basics,'age',xvar='year',ylab='age by year')
```
