---
title: "Hemoglobin distributions and trends"
author: "Timo Asikainen"
date: "2025-02-20" 
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r load-packages}
# install.packages('moments')
library(dplyr)
library(lubridate)
library(tidyr)
library(moments)
library(openxlsx)
```
```{r working-directory-and-file-paths}
param=list()
param$wd = getwd()

# getwd() might behave differently depending on the environment where it is run (console vs. Rmd),
# therefore checking if working directory is set to the src folder and moving up if yes.
if (grepl('[/\\]src[/\\]?',param$wd)) {
   param$wd = sub('[/\\]src([/\\]?)$','\\1',param$wd)
}

dir.create(file.path(param$wd,"results"),showWarnings = FALSE)
dir.create(file.path(param$wd,"log"),showWarnings = FALSE)
param$result.file = file.path(param$wd,"results","data.xlsx")

param$donationdata = 'C:/git_repot/DATA/donationdata.fortimo.rdata'

param$country = 'FI' # Maybe leaves this out from the exported data and assign upon import

# nb! check that the result and log files point to the right locations
# No log is currently written in this script
```

```{r load-data}
# The data is expected to be in the same for as in the long-term forecasts project, except for
# the column 'Hb' added in the donation table. The units used in Finland is g/l.
load(param$donationdata)
```


```{r load-and-process-data}
simple = donationdata$donation %>%
  # filter(BloodDonationTypeKey %in% c('Whole Blood (K)','No Donation (E)')) %>%
  # VisitNoDonation is used in Finland during the recent years instead of No Donation (E)
  left_join(donationdata$donor[,c('releaseID','DateOfBirth','Sex','BloodGroup')],by='releaseID')
simple$age= as.numeric(difftime(simple$DonationDate,simple$DateOfBirth),unit="weeks")/52.25
simple$month = as.factor(month(simple$DonationDate))
simple$year = year(simple$DonationDate)
simple$year.factor = as.factor(simple$year)

simple$limit=135
simple$limit[simple$Sex=='Female']=125
simple$deferred=0
simple$deferred[simple$Hb<simple$limit]=1

# donation0$limit=135
# donation0$limit[donation0$Sex=='Female']=125
# donation0$deferred=0
# donation0$deferred[donation0$Hb<donation0$limit]=1

# date of first donation
date0 = simple %>%
  group_by(releaseID) %>%
  summarise(date0=min(DonationDate),.groups='drop')

# first-time donations
donation0 = simple %>%
  inner_join(date0,join_by(x$DonationDate==y$date0,releaseID))

# repeat donations; sent for sentinel
donation.r = simple %>%
  left_join(cbind(date0,sent=1),join_by(x$DonationDate==y$date0,releaseID)) %>%
  filter(is.na(sent)) %>%
  select(-sent) %>%
  mutate(month=as.integer(month))

# donation0$year=year(donation0$DonationDate)
# donation0$year.factor=as.factor(donation0$year)
```

```{r prepare-for-export}
# Annual Hb distributions by Sex
data.sets=c('donation0','donation.r','simple')
hb.freq = NULL
for (ds in data.sets) {
  freq0 = get(ds) %>%
    mutate(data.set=if(ds == 'simple') 'all' else ds) %>%
    group_by(data.set,year,Sex,Hb) %>%
    summarise(n=n(),nas=sum(1*is.na(Hb)),deferred=sum(deferred,na.rm=TRUE),
              mean.age=mean(age,na.rm=TRUE),sd.age=sd(age,na.rm=TRUE),.groups='drop')
  hb.freq = if(is.null(hb.freq)) freq0 else rbind(hb.freq,freq0)
}

# Annual age distributions by Sex
data.sets=c('donation0','donation.r','simple')
age.freq = NULL
for (ds in data.sets) {
  freq0 = get(ds) %>%
    mutate(data.set=if(ds == 'simple') 'all' else ds,age=as.integer(age)) %>%
    group_by(data.set,year,Sex,age) %>%
    summarise(n=n(),nas=sum(1*is.na(Hb)),deferred=sum(deferred,na.rm=TRUE),mean=mean(Hb,na.rm=TRUE),sd=sd(Hb,na.rm=TRUE),.groups='drop')
  age.freq = if(is.null(freq)) freq0 else rbind(age.freq,freq0)
}

# Month statistics
monthly = NULL
for (ds in data.sets) {
  monthly0 = get(ds) %>%
    mutate(data.set=ds) %>%
    group_by(data.set,year,Sex,month) %>%
    summarise(n=n(),nas=sum(1*is.na(Hb)),deferred=sum(deferred,na.rm=TRUE),mean=mean(Hb,na.rm=TRUE),sd=sd(Hb,na.rm=TRUE),
              mean.age=mean(age,na.rm=TRUE),sd.age=sd(age,na.rm=TRUE),nas=sum(1*is.na(Hb)),.groups='drop') 
  monthly = if(is.null(monthly)) monthly0 else rbind(monthly,monthly0)
}
```

```{r export-data}
write.xlsx(list(annual.hb=hb.freq,annual.age=age.freq,montly.statistics=monthly),file=file.path(param$wd,'exported-statistics.xlsx'))
```

This is the end of the new part.

```{r function-definitions}
plotHbDist = function(data0,sex,cutoff,zoom=TRUE) {
  sex0=data0[data0$year>=2005&data0$Sex==sex & 
              !is.na(data0$Hb)&data0$BloodDonationTypeKey %in% c('Whole Blood (K)','No Donation (E)'),c('Hb')]  
  freq = sex0 %>%
    group_by(Hb) %>%
    summarise(n=n()) %>%
    mutate(prop=n/sum(n))

  limits = NULL
  if (zoom)
    limits = c(cutoff-5,cutoff+5)
  plot(prop~Hb,data=freq,type='l',lwd=2,xlim=limits)
  # freq.all %>% filter(Hb>=130,Hb<140)

  mean0=mean(sex0$Hb)
  sd0=sd(sex0$Hb)
  
  text(x=cutoff,y=0.03,labels=paste0('mean=',mean0,', sd=',sd0))
  
  ndist=dnorm(unique(freq$Hb),mean=mean0,sd=sd0)
  lines(unique(freq$Hb),ndist)
  abline(v=cutoff,col='blue')
  
  return(list(mean0=mean0,sd0=sd0))
}

estimateTrend = function(final) {
  final.longer = matToLonger(final)
  final.longer$interceptFemale=1
  final.longer$interceptFemale[final.longer$Sex=='Male']=0
  final.longer$interceptMale=1-final.longer$interceptFemale
  m=lm(value~0+interceptFemale+interceptMale+year:Sex,data=final.longer)
  print(summary(m))
  return(m)
}

matToLonger = function(mat) {
  df1=as.data.frame(pivot_longer(cbind(Sex=rownames(mat)[1:2],mat[1:2,]),colnames(mat),names_to='year'))
  df1$year=as.integer(df1$year)
  return(df1)
}

# This function is in active use, but it doesn't seem to refer the functions above
plotYearSex = function(m,relative=FALSE) {
  cofs = summary(m)$coeff
  conames=rownames(cofs)
  codf=data.frame(name=conames,estimate=cofs[,1])
  wh=grep('(Male|Female)',conames)
  codf$Sex[wh]=sub('.*(Male|Female).*','\\1',conames[wh])
  wh=grep('[0-9][0-9][0-9][0-9]',conames)
  codf$year[wh]=sub('[^0-9]+([0-9]+).*','\\1',conames[wh])
  codf=cbind(codf,confint(m))
  
  codf=codf[!is.na(codf$year),]
  pah=pivot_wider(codf,names_from='year',values_from='estimate',id_cols=c('Sex'))
  rn = as.vector(pah[,1])
  pah=as.data.frame(pah[,-1])
  rownames(pah)=rn$Sex
  
  means=apply(pah,1,mean)
  if (!relative)
    means=0*means
  
  pah=pah-means
  
  pah2=pivot_wider(codf,names_from='year',values_from='2.5 %',id_cols=c('Sex'))
  pah2=as.data.frame(pah2[,-1])
  pah2=pah2-means
  pah3=pivot_wider(codf,names_from='year',values_from='97.5 %',id_cols=c('Sex'))
  pah3=as.data.frame(pah3[,-1])
  pah3=pah3-means
  
  pah.all=rbind(pah,pah2,pah3)
  
  matplot(t(pah.all),type='l',lty=c(rep('solid',2),rep('dashed',4)),col=rep(c('red','blue'),2),axes=FALSE)
  axis(2)
  axis(side=1,at=1:ncol(pah.all),labels=colnames(pah.all))
  return(pah.all)
}
```


```{r distribution-analysis}
rectifyDistribution = function (data0,sex,cutoff,plot=TRUE) {
  sex0=data0[data0$Sex==sex&!is.na(data0$Hb)&data0$BloodDonationTypeKey %in% c('Whole Blood (K)','No Donation (E)'),c('Hb')]  
  freq = sex0 %>%
    group_by(Hb) %>%
    summarise(n=n()) %>%
    mutate(prop=n/sum(n))
  
    # qqnorm(data0$Hb)
  # stest =data0 %>% filter(sex=='Male',year==2010) %>% select(Hb) 
  # qqnorm(stest$Hb)

  mean0=mean(sex0$Hb)
  sd0=sd(sex0$Hb)

  # Estimoituja keskiarvoa ja -hajontaa vastaava normaalijakauma
  Hb.values = unique(freq$Hb)
  ndist=dnorm(Hb.values,mean=mean0,sd=sd0)
  
  # Käsittelemätön jakauma
  if (plot) {
    plot(prop~Hb,data=freq,type='l',lwd=2,xlim=NULL)
    lines(unique(freq$Hb),ndist)
  
  # Erotuskuvaaja, tämä ei ole kovin tärkeä mutta sama tietysti ottaa mukaan
    plot(freq$prop-ndist~Hb.values)
    abline(v=cutoff,col='blue')
    abline(h=c(-1,1)*0.0005,col='red')
  }

  cnt = 0
  freq2 = freq
  k = which(freq$Hb==cutoff) 
  while (TRUE) {
    diff = (freq2$prop-ndist)[1:(k-1)]
    wh = which(diff < -0.0005)
    if (length(wh) == 0)
      break
    wh0 = max(wh)
    ds0 = diff[wh0]
    
    diff.plus = (freq2$prop-ndist)[k:nrow(freq2)]
    wh = which(diff.plus > 0.0005)
    if (length(wh) == 0)
      break
    wh1 = min(wh)
    ds1 = diff.plus[wh1]
    
    to.adjust = min(-ds0,ds1)
    
    freq2$prop[wh0] = freq2$prop[wh0] + to.adjust
    freq2$prop[wh1+(k-1)] = freq2$prop[wh1+(k-1)] - to.adjust
    
    # print(paste(wh0,':',ds0,':',wh1+(k-1),':',ds1,'=>',to.adjust))
    
    cnt = cnt + 1
    if (cnt > 1000) {
      print('max iterations exceeded (back-stop)')
      break
    }
  }

  mean1=  freq2 %>% 
      mutate(mom=Hb*prop) %>%
      summarise(mean=sum(mom))
  mean1=as.numeric(mean1)
  sd1 =  freq2 %>% 
      mutate(mom=(Hb-as.numeric(mean1))^2*prop) %>%
      summarise(sdx=sum(mom)) 
  sd1=sqrt(as.numeric(sd1))

  if (plot) {
    plot(prop~Hb,data=freq2,type='l',lwd=3,xlim=NULL)
    ndist2=dnorm(Hb.values,mean=mean1,sd=sd1)
    lines(Hb.values,ndist2,col='red',lty='dotted',lwd=2)
    abline(v=cutoff,col='blue',lty='dashed')
    rect(mean1-5,0,mean1+5,0.001,col='pink',lwd=2)
    abline(v=mean1,lty='dotted',lwd=3)
    
    plot(freq2$prop-ndist2~Hb.values)
    abline(v=cutoff,col='blue',lty='dashed')
    abline(h=c(-1,1)*0.0005,col='red',lty='dashed')
  }

  return(list(dist=freq2,mean1=mean1,sd1=sd1))
}

```

```{r testing}
donation0 %>%
  filter(year>2015) %>%
  group_by(year,Sex) %>%
  summarise(mean(deferred),mean(Hb,na.rm=TRUE),sd=sd(Hb,na.rm=TRUE),nas=sum(1*is.na(Hb)))

temp1 <-as.Date("01/01/2023",format="%m/%d/%Y")
temp2 <-as.Date("01/01/2024",format="%m/%d/%Y")

# DonationDate>=temp1,DonationDate<temp2
dist.2023.male = simple %>%
  filter(year(DonationDate)==2023,Hb<135,Sex=='Male')
table(dist.2023.male$BloodDonationTypeKey)
```


The following chunk is to be preserved

```{r}
data0=simple
sex='Male'
cutoff=125
dist.male = rectifyDistribution(simple,'Male',cutoff)
dist.female = rectifyDistribution(simple,'Female',cutoff)
```

```{r age-fractions}
# in development, to be integrated in getMoments
breaks = c(-Inf,24,40,Inf)
labels = c('young','mid','old')
cut(16:70,breaks=breaks)
age.freq$age.group = cut(age.freq$age,breaks)
age.freq = age.freq %>% dplyr::select(-age.group)
str(age.freq)

year.totals = age.freq %>%
  group_by(year,Sex) %>%
  summarise(n2=sum(n),.groups='drop')

age2 = age.freq %>%
  mutate(group = cut(age,breaks,labels=labels)) %>%
  group_by(year,Sex,group) %>%
  summarise(n=sum(n),.groups='drop') %>%
  inner_join(year.totals,join_by(year,Sex)) %>%
  mutate(prop=n/n2) %>% # ,name=paste(year,Sex)) %>%
  pivot_wider(id_cols=c('year','Sex'),names_from='group',values_from='prop')
age2
?pivot_wider
```


```{r getmoments-function}
getMoments = function(freq,data.set='donation0',value.col='Hb',group.col='year',n.filter=100,age.freq=NULL,age.breaks=c(-Inf,24,40,Inf),age.labels=c('young','mid','old')) {
  # data = age.freq
  freq = data.frame(freq)
  
  if (is.null(n.filter) || is.na(n.filter))
    n.filter = 0
  
  wh = min(which(colnames(freq)==value.col))
  colnames(freq)[wh]='value'
  wh.group = min(which(colnames(freq)==group.col))
  colnames(freq)[wh.group]='group'

  new.basics.mean = freq %>%
    # filter(country=='FI') %>%
    filter(data.set=='donation0',!is.na(value)) %>% # These are the summary rows for NA; leave them out at this point
    group_by(group,Sex) %>%
    summarise(n2=sum(n-nas),deferred.prop=sum(deferred/n2),mean0=sum(value*(n-nas))/n2,.groups='drop')
  
  new.basics = freq %>%
    # filter(country=='FI') %>%
    filter(data.set=='donation0',!is.na(value)) %>% # These are the summary rows for NA; leave them out at this point
    # group_by(group,Sex) %>%
    inner_join(new.basics.mean,join_by(group,Sex)) %>%
    mutate(dev=value-mean0,prop=n/n2) %>%
    group_by(group,Sex) %>%
    summarise(mean=min(mean0),n0=min(n),n=min(n2),deferred.prop=min(deferred.prop),var=sum(prop*dev^2),sd=sqrt(var),
              skewness=sum(prop*(dev/sd)^3),kurtosis=sum(prop*(dev/sd)^4),.groups='drop') %>%
    mutate(sd.low=sqrt((n-1)*var/qchisq(c(.975), n-1))) %>%
    mutate(sd.hi =sqrt((n-1)*var/qchisq(c(.0275), n-1))) %>%
    mutate(mean.low=mean-qnorm(0.025)*sd/sqrt(n)) %>%
    mutate(mean.hi =mean-qnorm(0.975)*sd/sqrt(n)) %>%
    filter(n>n.filter) %>%
    data.frame()
  
  # wh = min(which(colnames(new.basics)=='value'))
  # colnames(new.basics)[wh]=value.col
  wh.group = min(which(colnames(new.basics)=='group'))
  colnames(new.basics)[wh.group]=group.col
  
  if (!is.null(age.freq)) {
    year.totals = age.freq %>%
      group_by(year,Sex) %>%
      summarise(n2=sum(n),age=mean(age),.groups='drop')
    
    age2 = age.freq %>%
      mutate(group = cut(age,breaks,labels=labels)) %>%
      group_by(year,Sex,group) %>%
      summarise(n=sum(n),.groups='drop') %>%
      inner_join(year.totals,join_by(year,Sex)) %>%
      mutate(prop=n/n2) %>% # ,name=paste(year,Sex)) %>%
      pivot_wider(id_cols=c('year','Sex'),names_from='group',values_from='prop')


    new.basics = new.basics %>%
      inner_join(age2,join_by(year,Sex)) %>%
      inner_join(year.totals[,c('year','Sex','age')],join_by(year,Sex))
  }

  
  return(new.basics)
}
```


```{r basics-processing}

# Mitä tietoja oikeastaan tarvittaisiin: jakauma itsessään(~), mean1, sd1, error (suhde normaalijakaumaan), korjauksen summa
# Jos ei plottaa, tämän saa kätevästi apply:lla (rivinumerot jos ei muu auta, kaivellaan sitten funktiossa esiin)

# pitäisikö käyttää myös donation.r erikseen? 
# Voisi laskea kokeeksi siihenkin

# simple$deferred[simple$Sex=='Female'&simple$Hb<125]=1
# simple$deferred[simple$Sex=='Male'&simple$Hb<135]=1

new.basics = getMoments(hb.freq,'donation0','Hb',age.freq=age.freq)

basics = donation0 %>% # simple
  filter(!is.na(Hb)) %>%
  group_by(year,Sex) %>%
  summarise(n=n(),mean0=mean(Hb,na.rm=TRUE),sd0=sd(Hb,na.rm=TRUE),deferred.prop=sum(deferred)/n(),
            limit=min(limit),age=mean(age),.groups='drop')

basics.all = simple %>% # simple
  filter(!is.na(Hb)) %>%
  group_by(year,Sex) %>%
  summarise(n=n(),mean.year=mean(Hb,na.rm=TRUE),sd0=sd(Hb,na.rm=TRUE),deferred.prop=sum(deferred)/n(),limit=min(limit),.groups='drop')

true.basics = simple %>%
  filter(!is.na(Hb)) %>%
  group_by(Sex) %>%
  summarise(n=n(),mean.all=mean(Hb,na.rm=TRUE),sd0=sd(Hb,na.rm=TRUE),deferred.prop=sum(deferred)/n(),limit=min(limit),.groups='drop')
true.basics$z=with(true.basics,(limit-mean.all)/sd0)
true.basics=data.frame(true.basics)
rownames(true.basics)=true.basics$Sex
true.basics$comp=true.basics$z[c(2,1)]*true.basics$sd0+true.basics$mean.all

true.basics$comp

basics = basics %>%
  inner_join(true.basics[,c('Sex','mean.all')],join_by(Sex)) %>%
  inner_join(basics.all[,c('Sex','mean.year','year')],join_by(Sex,year))

basics$mean1=NA
basics$sd1=NA

# Compute the adjusted means and standard deviations using rectified distributions
for (i in 1:nrow(basics)) {
  # nb! This used to be simple, eg. all donations were considered
  # Maybe should add them back
  # Probably best would be to add columns to distinguish between first time and repeat donors
  # Make a function to compile these stats for different subsets of donations: 1) first-time 2) repeat 3) all
  # Then see, what is useful
  # Probably should also convert the different mean etc. to columns, or should this be in fully long form? Maybe a mix
  rv = rectifyDistribution(donation0[donation0$year==basics$year[i],],basics$Sex[i],if(basics$Sex[i]=='Male') 135 else 125,FALSE)
  basics$mean1[i] = rv$mean1
  basics$sd1[i] = rv$sd1
}

basics$dperc0=pnorm(basics$limit,basics$mean0,basics$sd0)

# r.mat.long=pivot_longer(r.mat,colnames(r.mat),names_to='year')
# lm-adjusted means (year x sex)
# lm.data=pivot_longer(cbind(Sex=rownames(r.mat),r.mat)[1:2,],colnames(r.mat),names_to='year',values_to='mean.lm')
# lm.data$year=as.integer(lm.data$year)
# basics=left_join(basics,lm.data,join_by(year,Sex))
# basics$mean.lm[is.na(basics$mean.lm)]=0

# Compute the first adjusted value (dperc.nrm) using the all time averages for Hb (grouped by sex)
basics$dperc.nrm=pnorm(basics$limit+(basics$mean.year-basics$mean.all),basics$mean0,basics$sd0)
# basics$dperc.lm=pnorm(basics$limit+basics$mean.lm,basics$mean0,basics$sd0)
# basics$dperc.nrm.1=pnorm(basics$limit+(basics$mean.year-basics$mean.all),basics$mean1,basics$sd1)

sex.col=data.frame(sex=c('Female','Male'),col=c('Red','Blue'))

# This all should be done more systematically
# Should also be able to look at repeat deferrals
# Given the major differences in sd's, maybe should adjust for them as well;
# or rather, in the theoretical computations, the adjustment is already made.

# For plotting, should adjust:
# - b-labels with correct units (or none at all)
# - should be able to index values to 1 (or 100), especially for means
# - Maybe even multiple variables in same chart to enable comparison (mean,sd,deferral%)
# - and later country

# plot.cols=c('dperc0')
# basics 
plotColBySex = function(basics,col,ylab,xvar='year') {
  par(mar=c(2,4,0,4))
  plot.cols=c(col)
  plot(basics[[xvar]],basics[[plot.cols[1]]],type='n',ylab=ylab)
  for (i in 1:nrow(sex.col)) {
    data1 = basics[basics$Sex==sex.col$sex[i],]
    for (col in plot.cols) {
      lines(data1[[xvar]],data1[[col]],col=sex.col$col[i],lwd=2)
      
      for (suf in c('low','hi')) {
        ci.var = paste0(col,'.',suf)
        if (ci.var %in% names(basics)) {
          print(ci.var)
          lines(data1[[xvar]],data1[[ci.var]],lty='dotted',lwd=1,col=sex.col$col[i])
        }
      }
      
      frml=paste0(col,'~',xvar)
      m=lm(formula(frml),data=data1)
      sm=summary(m)
      # print(sm)
      # sm$coeff[2,4]
      abline(a=sm$coeff[1,1],b=sm$coeff[2,1],col=sex.col$col[i],lty='dashed',lwd=2)
      text(x=min(data1[[xvar]]),y=min(data1[[col]])+0.01,labels=paste0('b=',round(100*sm$coeff[2,1],5),'%,p=',round(sm$coeff[2,4],3)),adj=c(0))
    }
  }
}
# If and equivalent deferral limit would be applied to men as for women (z-value), the limit would be 138.8
# Similarly for women, the deferrallimit would be 121.5
```

``` {r plotting}
# means and such
plotColBySex(basics,'mean0','mean (actual data)')
plotColBySex(basics,'mean1','theoretical mean (adjusted)')
plotColBySex(basics,'sd0','sd (actual data)')
plotColBySex(basics,'sd1','theoretical sd (adjusted)')

# deferral rates
plotColBySex(basics,'deferred.prop','actual percentage deferred')
plotColBySex(basics,'dperc0','theoretical proportion deferred (unadjusted mean)')
plotColBySex(basics,'dperc.nrm','theoretical proportion deferred (adjusted mean)')
# plotColBySex(basics,'dperc.lm','adjusted using estimated mean differences')
```

``` {r new-lm-approach}
newLMapproach = function(basics) {
  # This block relies on basics, so need to make sure it can be computed with the summary data
  # Plus must add countries overall
  # This all seems to be based on basics
  par(mar=c(2,4,0,0))
  data=basics[basics$Sex=='Female',]
  data.female=data
  mean.female=mean(data$deferred.prop)
  plot(deferred.prop~mean,data=data,ylim=c(0,0.15),xlim=c(130,160),col='red')
  m=lm(deferred.prop~mean,data=data)
  m1=lm(deferred.prop~mean+sd,data=data)
  sm=summary(m)
  sm1=summary(m1)
  sm1.female=sm1
  
  m2.female=NULL
  if ('young' %in% colnames(data)) {
    m2.female=lm(deferred.prop~mean+sd+young+old,data=data)
  }

    abline(a=sm$coeff[1,1],b=sm$coeff[2,1],col='red',lty='dashed',lwd=2)
  text(x=135,y=0.03,labels=paste0('b=',round(sm1$coeff[2,1],3),'\np=',round(sm1$coeff[2,4],3),'\nR',intToUtf8(178),'=',round(sm1$r.squared,3)),adj=c(0))
  data=basics[basics$Sex=='Male',]
  m=lm(deferred.prop~mean,data=data)
  m1=lm(deferred.prop~mean+sd,data=data)
  sm=summary(m)
  sm1=summary(m1)
  abline(a=sm$coeff[1,1],b=sm$coeff[2,1],col='blue',lty='dashed',lwd=2)
  points(data$mean,data$deferred.prop,col='blue')
  text(x=155,y=0.06,labels=paste0('b=',round(sm1$coeff[2,1],3),'\np=',round(sm1$coeff[2,4],3),'\nR',intToUtf8(178),'=',round(sm1$r.squared,3)),adj=c(0))
  plot(data$year,sm1.female$residuals,col='red',ylim=c(-0.05,0.05),type='l',ylab='residuals',lwd=3)
  lines(data$year,sm1$residuals,col='blue',lwd=3)
  mean.male=mean(data$deferred.prop)
  lines(data$year,data.female$deferred.prop-mean.female,col='red',lty='dotted',lwd=2)
  lines(data$year,data$deferred.prop-mean.male,col='blue',lty='dotted',lwd=2)
  
  year=data$year
  residual=data.female$deferred.prop-mean.female
  m=lm(residual~year)
  summary(m)
  
  table(data$Sex)
  m1=lm(deferred.prop~mean+sd+age,data=data)
  summary(m1)
  
  m1=lm(deferred.prop~mean+sd+age,data=data.female)
  summary(m1)

  m2.male=NULL
  if ('young' %in% colnames(data)) {
    m2.male=lm(deferred.prop~mean+sd+young+old,data=data)
  }
  
  return(list(m.female=m2.female,m.male=m2.male))
}
```

```{r}
rv=newLMapproach(new.basics)
str(rv$m.female)
summary(rv$m.female)
summary(rv$m.male)
```


```{r statistics-by-age}

new.agedist = getMoments(age.freq,data.set='all',value.col='mean',group.col='age',n.filter=100)
plotColBySex(new.agedist,'mean',xvar = 'age',ylab='')
  
# Tässä itse asiassa lasketaan vuosikohtaisesti perusparametrit, erona vaan että luottamusvälit lisäksi
agedist = simple %>%
  mutate(age=as.integer(age)) %>%
  filter(!is.na(Hb),age<=70) %>%
  # nb! This is a pitfall, maybe should be done in other contexts as well for consistency
  # Maybe should manage this somehow differently
  filter(DonationPlaceType!='Garrison') %>% 
  group_by(age,Sex) %>%
  summarise(mean=mean(Hb),sd=sd(Hb,na.rm=TRUE),v=var(Hb),n=n(),.groups='drop') %>%
  mutate(sd.low=sqrt((n-1)*v/qchisq(c(.975), n-1))) %>%
  mutate(sd.hi =sqrt((n-1)*v/qchisq(c(.0275), n-1))) %>%
  mutate(mean.low=mean-qnorm(0.025)*sd/sqrt(n)) %>%
  mutate(mean.hi =mean-qnorm(0.975)*sd/sqrt(n)) %>%
  filter(n>100)

agedist
plotColBySex(agedist,'n',xvar = 'age',ylab='')
plotColBySex(agedist,'mean',xvar = 'age',ylab='')
plotColBySex(agedist,'sd',xvar = 'age',ylab='')

plotColBySex(basics,'age',xvar='year',ylab='age by year')
# Keskiarvolle keskivirhe: 
# Täällä näkyy naisilla kaksikyttyräinen muoto
# Mutta koska Hb on oleellisesti lineaarinen iän suhteen (pl. varuskuntaluovuttajat), voi silti käyttää keski-ikää
```

```{r}

```

